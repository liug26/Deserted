extends Timer

"""
Buff scene, generated by Player, changes some of players' properties
for some duration, and resets it back upon timer timeout. 
"""

# for easier access to nodes
onready var player = get_node("/root/Game/Player")
onready var light_mask = player.get_node("LightMask")
onready var ui = get_node("/root/Game/UI")
onready var game = get_node("/root/Game")
# if the timer has timeout or not, if set to true will prevent
# further updates
var timeout = false
# a number from 0-5, corresponding to one of the enums below, initialized
# by Player upon instantiating the scene
var type
# the types of buffs, the first four are buyable items, and the
# last two are collectible props
enum{SPEED, HEAL, RESURRECTION, GAME_PASS, VISION_EXPAND, ICE}


# receives a number from 0-5 indicating the type of the buff
func initialize(type):
	self.type = type
	game.connect("global_freeze", self, "_on_game_global_freeze")
	# speed gives player 5 seconds of fast speed
	if type == SPEED:
		wait_time = 5
		player.speed = 180
	# heal, resurrection and game pass are all instant buffs, meaning
	# that they do not last for a duration, start the effect upon
	# initialization, and do nothing upon freeing 
	elif type == HEAL:
		player.update_health(100)
	# when resurrection or game pass is acquired, calls Game.on_vital_items_acquired()
	elif type == RESURRECTION:
		player.resurrection = 1
		game.on_vital_items_acquired()
	elif type == GAME_PASS:
		player.game_pass = 1
		game.on_vital_items_acquired()
	# vision buff gives player 10 seconds of enlarged camera vision
	elif type == VISION_EXPAND:
		wait_time = 10
		if _get_buff_count(type) == 1:
			player.get_node("LightMask").texture_scale = 1.3
			player.get_node("Camera2D").zoom = Vector2(0.3, 0.3)
			player.get_node(("Camera2D/Area2D/CollisionShape2D")).shape.extents = Vector2(1024 * 0.25, 600 * 0.25)
	# ice freezes all enemies for 4 seconds
	elif type == ICE:
		wait_time = 4
		for enemy in get_tree().get_nodes_in_group("enemy"):
			enemy.freeze = true
	# updates UI's status scenes, only acquiring resurrection or
	# game pass will really update anything
	ui.update_status_ui()
	# start the timer
	start()


# some buffs require a transition and/or a continous update, do that here
func _process(delta):
	# if timer has timeout, do nothing because effects are already reset
	if timeout:
		return
	# vision expand has a small zooming out for the camera,
	# gradually update variables until they reach minimum/maximum
	if type == VISION_EXPAND:
		# also update the camera vision collision box and enlarge
		# the light mask a bit so that you can see more things
		# in the enlarged camera
		player.get_node("LightMask").texture_scale = min(1.7, player.get_node("LightMask").texture_scale + 0.1)
		player.get_node("Camera2D").zoom = Vector2(min(0.4, player.get_node("Camera2D").zoom.x + 0.01), min(0.4, player.get_node("Camera2D").zoom.y + 0.01))
		player.get_node(("Camera2D/Area2D/CollisionShape2D")).shape.extents = Vector2(1024 * (player.get_node("Camera2D").zoom.x - 0.09), 600 * (player.get_node("Camera2D").zoom.y - 0.09))
	# ice requires a continous update, otherwise if the player
	# opens the esc and closes it, which releases the global unfreeze
	# signal, it will cause the enemies to de-freeze thus overriding
	# this buff
	elif type == ICE:
		for enemy in get_tree().get_nodes_in_group("enemy"):
			enemy.freeze = true


# when timer timeout, buff ends and reset properties
func _on_timeout():
	"""
	speed, vision buff and ice buff can overlap, which means that
	there can be other same on-going buffs while a buff times out
	if the buff times out and resets the effect, that will nullify
	the effect of other on-going buffs. to avoid this, there are two
	methods, one is to check if there are other on-going buffs before
	resetting properties: if there are other same on-going buffs, don't
	reset but instead let the other buff do the resetting. Another way
	is to continously update the property, so that even if another buff
	resets the property, you can override the reset by setting it again
	speed and vision expand uses the first method, and ice uses the second
	"""
	if type == SPEED:
		if _get_buff_count(type) == 1:
			player.speed = 100
	elif type == VISION_EXPAND:
		if _get_buff_count(type) == 1:
			player.get_node("LightMask").texture_scale = 1.3
			player.get_node("Camera2D").zoom = Vector2(0.3, 0.3)
			player.get_node(("Camera2D/Area2D/CollisionShape2D")).shape.extents = Vector2(1024 * 0.25, 600 * 0.25)
	elif type == ICE:
		for enemy in get_tree().get_nodes_in_group("enemy"):
			enemy.freeze = false
	# because queue_free() frees the node on the next frame, you
	# could still get another effect update on the next frame before
	# the node frees. that will cause the effect to last forever because
	# the update happens after the timeout reset. so we have this timeout
	# bool to make sure that no updates can be made after timeout
	timeout = true
	queue_free()


# when global freeze signal is emitted from Game, stop/resume timer
func _on_game_global_freeze(freeze):
	if freeze:
		stop()
	else:
		start()


# returns how many buffs of type type there are
func _get_buff_count(type):
	var buff_count = 0
	for buff in get_tree().get_nodes_in_group("buffs"):
		if buff.type == type:
			buff_count += 1
	return buff_count
